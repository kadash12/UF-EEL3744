;******************************************************************************
;Lab 4 Part 3
;Section #: 1823
;Name: Johnny Li
;Class #: 12378
;PI Name: Jared Holley
;Description: INTERFACING WITH EXTERNAL SRAM
;*********************************INCLUDES*************************************
.include "ATxmega128a1udef.inc"
;******************************END OF INCLUDES*********************************
;******************************DEFINED SYMBOLS*********************************
.equ SRAM = 0x170000	//SRAM table starting address
.equ IO = 0x037000	//IO table starting address
.equ IN_TABLE_START_ADDR = 0x3000	//Input table starting address
;**************************END OF DEFINED SYMBOLS******************************
;******************************MEMORY CONSTANTS********************************
	;Given table content
	.org IN_TABLE_START_ADDR
DATA:
.db 0x4d, 0x61, 0x6b, 0x69, 0x6e, 0x67, 0x20, 0x79, 0x6f, 0x75
.db 0x72, 0x20, 0x77, 0x61, 0x79, 0x20, 0x69, 0x6e, 0x20, 0x74
.db 0x68, 0x65, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x20, 0x74
.db 0x6f, 0x64, 0x61, 0x79, 0x20, 0x74, 0x61, 0x6b, 0x65, 0x73
.db 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x74, 0x68, 0x69, 0x6e
.db 0x67, 0x20, 0x79, 0x6f, 0x75, 0x27, 0x76, 0x65, 0x20, 0x67
.db 0x6f, 0x74, 0x2e, 0x0a, 0x54, 0x61, 0x6b, 0x69, 0x6e, 0x67
.db 0x20, 0x61, 0x20, 0x62, 0x72, 0x65, 0x61, 0x6b, 0x20, 0x66
.db 0x72, 0x6f, 0x6d, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x79, 0x6f
.db 0x75, 0x72, 0x20, 0x77, 0x6f, 0x72, 0x72, 0x69, 0x65, 0x73
.db 0x2c, 0x20, 0x73, 0x75, 0x72, 0x65, 0x20, 0x77, 0x6f, 0x75
.db 0x6c, 0x64, 0x20, 0x68, 0x65, 0x6c, 0x70, 0x20, 0x61, 0x20
.db 0x6c, 0x6f, 0x74, 0x2e, 0x0a, 0x57, 0x6f, 0x75, 0x6c, 0x64
.db 0x6e, 0x27, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x20, 0x6c, 0x69
.db 0x6b, 0x65, 0x20, 0x74, 0x6f, 0x20, 0x67, 0x65, 0x74, 0x20
.db 0x61, 0x77, 0x61, 0x79, 0x3f, 0x0a, 0x53, 0x6f, 0x6d, 0x65
.db 0x74, 0x69, 0x6d, 0x65, 0x73, 0x20, 0x79, 0x6f, 0x75, 0x20
.db 0x77, 0x61, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x67, 0x6f
.db 0x0a, 0x57, 0x68, 0x65, 0x72, 0x65, 0x20, 0x65, 0x76, 0x65
.db 0x72, 0x79, 0x62, 0x6f, 0x64, 0x79, 0x20, 0x6b, 0x6e, 0x6f
.db 0x77, 0x73, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x6e, 0x61
.db 0x6d, 0x65, 0x2c, 0x0a, 0x61, 0x6e, 0x64, 0x20, 0x74, 0x68
.db 0x65, 0x79, 0x27, 0x72, 0x65, 0x20, 0x61, 0x6c, 0x77, 0x61
.db 0x79, 0x73, 0x20, 0x67, 0x6c, 0x61, 0x64, 0x20, 0x79, 0x6f
.db 0x75, 0x20, 0x63, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x59, 0x6f
.db 0x75, 0x20, 0x77, 0x61, 0x6e, 0x6e, 0x61, 0x20, 0x62, 0x65
.db 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x79, 0x6f, 0x75
.db 0x20, 0x63, 0x61, 0x6e, 0x20, 0x73, 0x65, 0x65, 0x2c, 0x0a
.db 0x6f, 0x75, 0x72, 0x20, 0x74, 0x72, 0x6f, 0x75, 0x62, 0x6c
.db 0x65, 0x73, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61, 0x6c, 0x6c
.db 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x0a
.db 0x59, 0x6f, 0x75, 0x20, 0x77, 0x61, 0x6e, 0x6e, 0x61, 0x20
.db 0x62, 0x65, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x65
.db 0x76, 0x65, 0x72, 0x79, 0x62, 0x6f, 0x64, 0x79, 0x20, 0x6b
.db 0x6e, 0x6f, 0x77, 0x73, 0x0a, 0x59, 0x6f, 0x75, 0x72, 0x20
.db 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x0a, 0x59, 0x6f, 0x75, 0x20
.db 0x77, 0x61, 0x6e, 0x6e, 0x61, 0x20, 0x67, 0x6f, 0x20, 0x77
.db 0x68, 0x65, 0x72, 0x65, 0x20, 0x70, 0x65, 0x6f, 0x70, 0x6c
.db 0x65, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x2c, 0x0a, 0x70, 0x65
.db 0x6f, 0x70, 0x6c, 0x65, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61
.db 0x6c, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d
.db 0x65, 0x2c, 0x0a, 0x59, 0x6f, 0x75, 0x20, 0x77, 0x61, 0x6e
.db 0x6e, 0x61, 0x20, 0x67, 0x6f, 0x20, 0x77, 0x68, 0x65, 0x72
.db 0x65, 0x20, 0x65, 0x76, 0x65, 0x72, 0x79, 0x62, 0x6f, 0x64
.db 0x79, 0x20, 0x6b, 0x6e, 0x6f, 0x77, 0x73, 0x0a, 0x79, 0x6f
.db 0x75, 0x72, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x2e, 0x20, 0x20
DATA_END:		; TABLE SIZE
;***************************END OF MEMORY CONSTANTS****************************
;********************************MAIN PROGRAM**********************************
	.cseg
.org 0x0000
	rjmp MAIN

.org 0x100
MAIN:
	ldi r16, 0b00110011		; Since RE(L), WE(L), CS0(L) and CS1(L) are active low signals, we must set  
	sts PORTH_OUTSET, r16	; the default output to 1 = H = false. See 8331, sec 27.9.
							; (ALE defaults to 0 = L = false)

	ldi r16, 0b00110111		; Configure the PORTH bits 4, 2 and 1 as outputs. 
	sts PORTH_DIRSET, r16 	; These are the CS1(L), CS0(L), ALE1(H), WE(L) and RE(L) outputs. 
							; (CS0 is bit 4; ALE1 is bit 2; RE is bit 1)
							; see 8385, Table 33-7
	
	ldi r16, 0xFF			; Set all PORTK pins (A15-A0) to be outputs. As requried	
	sts PORTK_DIRSET, r16	; in the data sheet. See 8331, sec 27.9.
							
							; Set all PORTJ pins (D7-D0) to be outputs. As requried 
	sts PORTJ_DIRSET, r16	; in the data sheet. See 8331, sec 27.9.
		
	ldi r16, 0x01			; Store 0x01 in EBI_CTRL register to select 3 port EBI(H,J,K) 
	sts EBI_CTRL, r16		; mode and SRAM ALE1 mode.

;Reserve a chip-select zone for our input port. The base address register is made up of
;  12 bits for the address (A23:A12). The lower 12 bits of the address (A11-A0) are 
;  assumed to be zero. This limits our choice of the base addresses.

;ENABLE SRAM------------------------------------------------------------------------------
; Set to size chip select space and turn on SRAM mode.
	ldi r16, 0b00011101	;32k		
	sts EBI_CS0_CTRLA, r16				
	
;ENABLE IO-----------------------------------------------------------------------------------------
	; Set to size chip select space and turn on SRAM mode.
	ldi r16, 0x01	;256	
	sts EBI_CS1_CTRLA, r16		

	; point appropriate indices to input/output tables
	;Z points to input table.
	ldi ZL, low(DATA << 1) ; Shift due to being 16-bits in a 8-bit processor 
	ldi ZH, high(DATA << 1) ; Z points to the table
	ldi r16, BYTE3(DATA << 1)
    sts CPU_RAMPZ,r16

	;Y points to input table.
	ldi YL, low(IO) ; Shift due to being 16-bits in a 8-bit processor 
	ldi YH, high(IO) ; Z points to the table
	ldi r16, BYTE3(IO)
    sts CPU_RAMPY,r16

	;X points to input table.
	ldi XL, low(SRAM) ; Shift due to being 16-bits in a 8-bit processor 
	ldi XH, high(SRAM) ; Z points to the table
	ldi r16, BYTE3(SRAM)
    sts CPU_RAMPX,r16
;Initialize--------------------------------------------------------------
;Load the middle byte (A15:8) of the three byte address into a register and store it as the 
;  LOW Byte of the Base Address, BASEADDRL.  This will store only bits A15:A12 and ignore 
;  anything in A11:8 as again, they are assumed to be zero. 
	ldi r16, byte2(SRAM)
	sts EBI_CS0_BASEADDR, r16

;Load the highest byte (A23:16) of the three byte address into a register and store it as the 
;  HIGH byte of the Base Address, BASEADDRH.
	ldi r16, byte3(SRAM)
	sts EBI_CS0_BASEADDR+1, r16

;Load the middle byte (A15:8) of the three byte address into a register and store it as the 
;  LOW Byte of the Base Address, BASEADDRL.  This will store only bits A15:A12 and ignore 
;  anything in A11:8 as again, they are assumed to be zero. 
	ldi r16, byte2(IO)
	sts EBI_CS1_BASEADDR, r16

;Load the highest byte (A23:16) of the three byte address into a register and store it as the 
;  HIGH byte of the Base Address, BASEADDRH.
	ldi r16, byte3(IO)
	sts EBI_CS1_BASEADDR+1, r16


	; loop through input table
LOOP:
	; load value from input table into an appropriate register
	elpm r16,Z+
	;Store in SRAM
	st X+, r16
	; determine if the end of table has been reached (perform general check)
	cpi r16, 0xFF	;compare NULL and r16 to see if NULL is reached

	; if end of table (EOT) has not been reached,
	BRNE Loop

	;Reset X points to SRAM
	ldi XL, low(SRAM)  
	ldi XH, high(SRAM) 
	ldi r16, BYTE3(SRAM)
    sts CPU_RAMPX,r16
READ:
	//READ to LED
	ld r16,x+
	st Y,r16

	;Initialize Counter  
	ldi r22, 0b0111 ;Prescaler 512 
	sts TCC0_CTRLA, r22 ;Sets the Clock Select from Register A
	 
	;Load high and low byte of Period  
	ldi r22, 0xA2 ;Load r16 with 0x62  
	sts TCC0_PER, r22 ;Store low byte first  
	ldi r22, 07;Load r16 with 01  
	sts TCC0_PER + 1, r22 ;Store high byte 

	;Check Overflow 
	FLAG1:  
	lds r20, TCC0_INTFLAGS ;Loads the Flag into r20  
	sbrs r20, 0 ;Compares r20 with 0  
	rjmp FLAG1 ;rjmp to FLAG1 until SET  

	sts TCC0_INTFLAGS, r20 ;Store this value into the INTFLAGS Register    
	cpi r16, 0 ;Compare r16 with 0  
	brne READ

	;Branches to repeat if not equal to zero  
	rjmp LOOP ;Branches to loop if it is 0 

	;End of program (never reached)
DONE: 
	rjmp DONE
;*****************************END OF MAIN PROGRAM *****************************
;*****************************END OF "lab4_2.asm"******************************
